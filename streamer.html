<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer (WebRTC Auto)</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
    <div class="card">
        <div class="card-header"><span class="dot red"></span><span class="title-text">./webrtc_broadcast.sh</span></div>
        <div class="card-body">
            <h2 id="status">–ó–∞–ø—É—Å–∫ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏...</h2>
            <p>–ó–∞—Ö–≤–∞—Ç –∫–∞–º–µ—Ä—ã –∏ –æ–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∑—Ä–∏—Ç–µ–ª—è.</p>
            <video id="localVideo" autoplay muted playsinline style="width:100%; border-radius: 8px; background: #000;"></video>
        </div>
    </div>
</div>
<script>
    const statusEl = document.getElementById('status');
    const localVideo = document.getElementById('localVideo');
    const SERVER_URL = 'wss://9d2488b5-3986-4269-bfdd-d01f421e0f4c-00-asck2nhxkvc6.pike.replit.dev/';
    let peerConnection;

    // --- –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
    const config = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun.services.mozilla.com' },
        // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ TURN —Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö —Å–µ—Ç–µ–π
        {
          urls: 'turn:openrelay.metered.ca:80',
          username: 'openrelayproject',
          credential: 'openrelayproject'
        }
      ]
    };
    // --------------------------------

    const ws = new WebSocket(SERVER_URL, 'streamer');

    ws.onopen = async () => {
        statusEl.textContent = 'üü¢ –°–µ—Ä–≤–µ—Ä –ø–æ–¥–∫–ª—é—á–µ–Ω. –í–∫–ª—é—á–∞—é –∫–∞–º–µ—Ä—É...';
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
            localVideo.srcObject = stream;
            
            peerConnection = new RTCPeerConnection(config);

            // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            peerConnection.onconnectionstatechange = () => {
                console.log('Streamer Connection State:', peerConnection.connectionState);
                statusEl.textContent = `–°—Ç–∞—Ç—É—Å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è: ${peerConnection.connectionState}`;
            };
            
            stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ type: 'ice-candidate', candidate: event.candidate }));
                }
            };
            
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            ws.send(JSON.stringify({ type: 'offer', sdp: offer.sdp, }));
            statusEl.textContent = '‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∑—Ä–∏—Ç–µ–ª—è...';

        } catch (err) {
            statusEl.textContent = '‚õîÔ∏è –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ.';
        }
    };

    ws.onmessage = async event => {
        const message = JSON.parse(event.data);
        if (message.type === 'answer') {
            if (!peerConnection.currentRemoteDescription) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message));
            }
        } else if (message.type === 'ice-candidate') {
            await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
        }
    };

    ws.onclose = () => { statusEl.textContent = 'üî¥ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º –ø–æ—Ç–µ—Ä—è–Ω–æ.'; };
</script>
</body>
</html>
