<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer (WebRTC Auto)</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
    <div class="card">
        <div class="card-header"><span class="dot red"></span><span class="title-text">./webrtc_broadcast.sh</span></div>
        <div class="card-body">
            <h2 id="status">–ó–∞–ø—É—Å–∫ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏...</h2>
            <p>–≠—Ç–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –±—É–¥–µ—Ç —Ç—Ä–∞–Ω—Å–ª–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ, –∫–æ–≥–¥–∞ –ø–æ–¥–∫–ª—é—á–∏—Ç—Å—è –∑—Ä–∏—Ç–µ–ª—å.</p>
            <video id="localVideo" autoplay muted playsinline style="width:100%; border-radius: 8px; background: #000;"></video>
        </div>
    </div>
</div>
<script>
    const statusEl = document.getElementById('status');
    const localVideo = document.getElementById('localVideo');
    const SERVER_URL = 'wss://9d2488b5-3986-4269-bfdd-d01f421e0f4c-00-asck2nhxkvc6.pike.replit.dev/';
    let peerConnection;
    let localStream; // –°–æ—Ö—Ä–∞–Ω–∏–º –ø–æ—Ç–æ–∫, —á—Ç–æ–±—ã –Ω–µ –∑–∞–ø—Ä–∞—à–∏–≤–∞—Ç—å –∫–∞–º–µ—Ä—É –∫–∞–∂–¥—ã–π —Ä–∞–∑
    const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'stun:stun1.l.google.com:19302' }] };

    async function initializeStreamer() {
        statusEl.textContent = '–í–∫–ª—é—á–∞—é –∫–∞–º–µ—Ä—É...';
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
            localVideo.srcObject = localStream;
            statusEl.textContent = 'üü¢ –ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞. –û–∂–∏–¥–∞–Ω–∏–µ –∑—Ä–∏—Ç–µ–ª–µ–π...';
            connectToSignaling();
        } catch (err) {
            statusEl.textContent = '‚õîÔ∏è –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ.';
        }
    }

    function connectToSignaling() {
        const ws = new WebSocket(SERVER_URL, 'streamer');

        ws.onopen = () => { statusEl.textContent = 'üü¢ –ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞. –û–∂–∏–¥–∞–Ω–∏–µ –∑—Ä–∏—Ç–µ–ª–µ–π...'; };

        // –ì–õ–ê–í–ù–ê–Ø –õ–û–ì–ò–ö–ê –¢–ï–ü–ï–†–¨ –ó–î–ï–°–¨
        ws.onmessage = async event => {
            const message = JSON.parse(event.data);
            
            if (message.type === 'viewer-connected') {
                statusEl.textContent = 'üîå –û–±–Ω–∞—Ä—É–∂–µ–Ω –Ω–æ–≤—ã–π –∑—Ä–∏—Ç–µ–ª—å, —Å–æ–∑–¥–∞—é —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ...';
                if (peerConnection) { peerConnection.close(); } // –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
                peerConnection = new RTCPeerConnection(config);
                
                localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                peerConnection.onicecandidate = e => {
                    if (e.candidate) { ws.send(JSON.stringify({ type: 'ice-candidate', candidate: e.candidate })); }
                };
                
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                ws.send(JSON.stringify(offer)); // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º offer –∑—Ä–∏—Ç–µ–ª—é

            } else if (message.type === 'answer') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(message));
                statusEl.textContent = '‚úÖ –¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è –∞–∫—Ç–∏–≤–Ω–∞!';

            } else if (message.type === 'ice-candidate') {
                await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
            }
        };

        ws.onclose = () => {
            statusEl.textContent = 'üî¥ –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º –ø–æ—Ç–µ—Ä—è–Ω–æ. –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 5—Å...';
            setTimeout(connectToSignaling, 5000);
        };
    }
    
    initializeStreamer();
</script>
</body>
</html>
